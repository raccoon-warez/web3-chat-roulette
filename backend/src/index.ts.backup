import express from 'express';
import http from 'http';
import WebSocket from 'ws';
import cors from 'cors';
import dotenv from 'dotenv';
import cron from 'node-cron';
import cookieParser from 'cookie-parser';
import { initializeDatabase, createTables } from './utils/database';
import { initializeRedis } from './utils/redis';
import { signalingService } from './services/signaling-service';
import { webrtcService } from './services/webrtc-service';
import authenticateToken, { authenticateWebSocket } from './middleware/auth';
import { generalRateLimit, wsConnectionRateLimit } from './middleware/rateLimiter';
import { 
  helmetConfig, 
  corsConfig, 
  hppProtection, 
  mongoSanitization,
  compressionConfig,
  customSecurityHeaders,
  securityLogging,
  ipFilter,
  contentLengthValidator,
  websocketSecurityHeaders,
  securityErrorHandler
} from './middleware/security';
import { sanitizeRequest } from './middleware/validation';

// Load environment variables first
dotenv.config();

// Validate required environment variables
const requiredEnvVars = ['JWT_ACCESS_SECRET', 'JWT_REFRESH_SECRET', 'REDIS_URL'];
const missingEnvVars = requiredEnvVars.filter(varName => !process.env[varName]);

if (missingEnvVars.length > 0) {
  console.warn('Warning: Missing environment variables:', missingEnvVars);
  console.warn('Some security features may use fallback values');
}

// Create Express app
const app = express();
const server = http.createServer(app);

// Trust proxy (important for rate limiting and IP detection)
app.set('trust proxy', 1);

// Security middleware (order is important)
app.use(helmetConfig);
app.use(cors(corsConfig));
app.use(cookieParser());
app.use(compressionConfig);
app.use(express.json({ limit: '1mb' }));
app.use(express.urlencoded({ extended: true, limit: '1mb' }));
app.use(hppProtection);
app.use(mongoSanitization);
app.use(contentLengthValidator());
app.use(customSecurityHeaders);
app.use(securityLogging);
app.use(ipFilter);
app.use(sanitizeRequest);

// Apply general rate limiting to all routes
app.use(generalRateLimit);

// Health check endpoint (no authentication required)
app.get('/health', (req, res) => {
  res.status(200).json({ 
    status: 'OK',
    timestamp: new Date().toISOString(),
    version: process.env.npm_package_version || '1.0.0'
  });
});

// Security endpoint for monitoring
app.get('/security/status', authenticateToken, (req, res) => {
  res.json({
    securityFeatures: {
      rateLimiting: true,
      authentication: true,
      inputValidation: true,
      securityHeaders: true,
      cors: true,
      compression: true,
      logging: true,
      ipFiltering: true
    },
    timestamp: new Date().toISOString()
  });
});

// Import routes
import authRoutes from './routes/auth';
import reportRoutes from './routes/reports';
import blockRoutes from './routes/blocks';
import balanceRoutes from './routes/balances';

// Use routes with specific middleware
app.use('/auth', authRoutes);
app.use('/reports', reportRoutes);
app.use('/blocks', blockRoutes);
app.use('/balances', balanceRoutes);

// WebSocket server with security enhancements
const wss = new WebSocket.Server({ 
  server,
  verifyClient: async (info: any) => {
    try {
      const clientIp = info.req.socket.remoteAddress || 'unknown';
      
      // Rate limiting for WebSocket connections
      const rateLimitOk = await wsConnectionRateLimit(clientIp);
      if (!rateLimitOk) {
        console.warn(`WebSocket rate limit exceeded for IP: ${clientIp}`);
        return false;
      }
      
      // Validate WebSocket upgrade request
      const url = new URL(info.req.url || '', `ws://${info.req.headers.host}`);
      const token = url.searchParams.get('token') || 
        (info.req.headers.authorization?.replace('Bearer ', ''));
      
      // Optional: Require authentication for WebSocket connections
      if (process.env.WS_REQUIRE_AUTH === 'true' && token) {
        const authResult = await authenticateWebSocket(token);
        if (!authResult) {
          console.warn(`WebSocket authentication failed for IP: ${clientIp}`);
          return false;
        }
      }
      
      return true;
    } catch (error) {
      console.error('WebSocket verification error:', error);
      return false; // Reject connection on errors
    }
  }
});

// WebSocket connection handling with enhanced security
wss.on('connection', async (ws: WebSocket, req) => {
  const clientIp = req.socket.remoteAddress || 'unknown';
  
  try {
    // Extract and validate connection parameters
    const url = new URL(req.url || '', `ws://${req.headers.host}`);
    const userId = url.searchParams.get('userId');
    const token = url.searchParams.get('token') || 
      (req.headers.authorization?.replace('Bearer ', ''));
    
    let authenticatedUser = null;
    
    // Authenticate if token is provided
    if (token) {
      authenticatedUser = await authenticateWebSocket(token);
      if (!authenticatedUser) {
        console.warn(`Invalid WebSocket token from ${clientIp}`);
        ws.close(1008, 'Invalid authentication token');
        return;
      }
    }
    
    console.log('New WebSocket connection established:', {
      clientIp,
      userId,
      authenticated: !!authenticatedUser,
      userAddress: authenticatedUser?.address,
      timestamp: new Date().toISOString()
    });
    
    // Set up connection timeout
    const connectionTimeout = setTimeout(() => {
      console.warn('WebSocket connection timeout');
      ws.close(1000, 'Connection timeout');
    }, 5 * 60 * 1000); // 5 minutes
    
    // Clear timeout on activity
    const clearConnectionTimeout = () => {
      clearTimeout(connectionTimeout);
    };
    
    // Handle connection with enhanced signaling service
    signalingService.handleConnection(ws, userId || undefined);
    
    // Security: Monitor for suspicious activity
    let messageCount = 0;
    const messageLimit = 100; // messages per minute
    const messageLimitWindow = 60 * 1000; // 1 minute
    let messageWindowStart = Date.now();
    
    ws.on('message', (data) => {
      clearConnectionTimeout();
      
      // Message rate limiting
      const now = Date.now();
      if (now - messageWindowStart > messageLimitWindow) {
        messageCount = 0;
        messageWindowStart = now;
      }
      
      messageCount++;
      if (messageCount > messageLimit) {
        console.warn(`WebSocket message rate limit exceeded for ${clientIp}`);
        ws.close(1008, 'Message rate limit exceeded');
        return;
      }
      
      // Message size validation
      const messageSize = Buffer.isBuffer(data) ? data.length : 
        (data instanceof ArrayBuffer ? data.byteLength : data.toString().length);
      if (messageSize > 10240) { // 10KB limit
        console.warn(`WebSocket message too large from ${clientIp}: ${messageSize} bytes`);
        ws.close(1009, 'Message too large');
        return;
      }
      
      try {
        // Validate JSON structure
        const message = JSON.parse(data.toString());
        
        // Basic message sanitization
        if (typeof message === 'object' && message !== null) {
          // Log potentially suspicious messages
          if (JSON.stringify(message).includes('<script>') || 
              JSON.stringify(message).includes('javascript:')) {
            console.warn(`Suspicious WebSocket message from ${clientIp}`);
          }
        }
      } catch (error) {
        console.warn(`Invalid WebSocket message format from ${clientIp}`);
        ws.close(1003, 'Invalid message format');
        return;
      }
    });
    
    ws.on('close', () => {
      clearTimeout(connectionTimeout);
      console.log(`WebSocket connection closed for ${clientIp}`);
    });
    
    ws.on('error', (error) => {
      clearTimeout(connectionTimeout);
      console.error('WebSocket error:', error);
    });
    
  } catch (error) {
    console.error('WebSocket connection error:', error);
    ws.close(1011, 'Server error');
  }
});

// Add WebRTC monitoring endpoint with authentication
app.get('/api/webrtc/stats', authenticateToken, (req, res) => {
  try {
    res.json({
      activeSessions: signalingService.getActiveSessionsCount(),
      queues: signalingService.getQueueStatus(),
      timestamp: Date.now(),
      uptime: process.uptime()
    });
  } catch (error) {
    console.error('Failed to get WebRTC stats:', error);
    res.status(500).json({ 
      error: 'Failed to retrieve statistics',
      code: 'STATS_FETCH_FAILED' 
    });
  }
});

// Add WebRTC configuration endpoint with rate limiting
app.get('/api/webrtc/config', generalRateLimit, async (req, res) => {
  try {
    const config = await webrtcService.generateWebRTCConfig();
    
    // Add security headers for WebRTC config
    res.set({
      'Cache-Control': 'private, no-cache, no-store, must-revalidate',
      'Pragma': 'no-cache',
      'Expires': '0'
    });
    
    res.json(config);
  } catch (error) {
    console.error('Failed to generate WebRTC config:', error);
    res.status(500).json({ 
      error: 'Failed to generate WebRTC configuration',
      code: 'WEBRTC_CONFIG_FAILED'
    });
  }
});

// Catch-all route for undefined endpoints
app.use('*', (req, res) => {
  res.status(404).json({ 
    error: 'Endpoint not found',
    code: 'NOT_FOUND',
    path: req.originalUrl,
    method: req.method,
    timestamp: new Date().toISOString()
  });
});

// Security-focused error handler (must be last)
app.use(securityErrorHandler);

// Setup cron jobs for cleanup and maintenance
cron.schedule('*/5 * * * *', () => {
  console.log('Running scheduled cleanup...');
  webrtcService.cleanup();
});

// Clean up expired tokens and rate limit entries
cron.schedule('0 * * * *', async () => {
  console.log('Running security cleanup...');
  try {
    // This would typically clean up expired entries in Redis
    // For now, we'll just log the activity
    console.log('Security cleanup completed');
  } catch (error) {
    console.error('Security cleanup error:', error);
  }
});

// Initialize database and Redis with error handling
const initializeServices = async () => {
  try {
    console.log('Initializing services...');
    
    await initializeDatabase();
    console.log('Database initialized');
    
    await createTables();
    console.log('Database tables created');
    
    await initializeRedis();
    console.log('Redis initialized');
    
    console.log('All services initialized successfully');
  } catch (error) {
    console.error('Service initialization error:', error);
    throw error;
  }
};

// Graceful shutdown handling
const gracefulShutdown = (signal: string) => {
  console.log(`Received ${signal}. Starting graceful shutdown...`);
  
  server.close(() => {
    console.log('HTTP server closed');
    
    // Close WebSocket connections
    wss.clients.forEach((ws) => {
      ws.close(1000, 'Server shutdown');
    });
    
    console.log('WebSocket connections closed');
    console.log('Graceful shutdown completed');
    process.exit(0);
  });
  
  // Force shutdown after timeout
  setTimeout(() => {
    console.error('Could not close connections in time, forcefully shutting down');
    process.exit(1);
  }, 10000);
};

// Register shutdown handlers
process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
process.on('SIGINT', () => gracefulShutdown('SIGINT'));

// Handle uncaught exceptions and unhandled rejections
process.on('uncaughtException', (error) => {
  console.error('Uncaught Exception:', error);
  gracefulShutdown('UNCAUGHT_EXCEPTION');
});

process.on('unhandledRejection', (reason, promise) => {
  console.error('Unhandled Rejection at:', promise, 'reason:', reason);
  gracefulShutdown('UNHANDLED_REJECTION');
});

// Initialize services and start server
initializeServices().then(() => {
  const PORT = process.env.PORT || 3001;
  const HOST = process.env.HOST || '0.0.0.0';
  
  server.listen(parseInt(PORT.toString()), HOST, () => {
    console.log(`🚀 Server running on ${HOST}:${PORT}`);
    console.log(`🛡️  Security features enabled: Authentication, Rate Limiting, Input Validation`);
    console.log(`📊 WebRTC endpoints: /api/webrtc/config, /api/webrtc/stats`);
    console.log(`🔐 Auth endpoints: /auth/siwe/nonce, /auth/siwe/verify, /auth/refresh`);
    console.log(`Environment: ${process.env.NODE_ENV || 'development'}`);
  });
}).catch((error) => {
  console.error('Failed to initialize services:', error);
  process.exit(1);
});
